import { GoogleGenAI } from "@google/genai";

let ai: GoogleGenAI | null = null;

const getAIClient = () => {
  if (ai) return ai;

  // The API key is provided by the execution environment via process.env.API_KEY.
  // The previous implementation was too defensive for this environment, resulting in an invalid API key.
  ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  return ai;
};

/**
 * Generates a spooky version of the uploaded image based on the selected style.
 * Uses 'gemini-2.5-flash-image' (Nano Banana) as requested.
 */
export const generateSpookyImage = async (
  base64Image: string,
  stylePrompt: string
): Promise<string> => {
  try {
    const client = getAIClient();

    // 1. Detect Mime Type
    // Robust Regex to catch image/jpeg, image/png, etc.
    const mimeMatch = base64Image.match(/^data:([^;]+);base64,(.+)$/);
    let mimeType = 'image/jpeg';
    let cleanBase64 = base64Image;

    if (mimeMatch && mimeMatch.length === 3) {
      mimeType = mimeMatch[1];
      cleanBase64 = mimeMatch[2];
    } else {
      // Clean up raw base64 if it has a prefix we didn't catch or just split by comma
      const split = base64Image.split(',');
      if (split.length === 2) {
          cleanBase64 = split[1];
          // Simple inference if header is missing but data is clean
          if (base64Image.trim().startsWith('iVBOR')) mimeType = 'image/png';
      }
    }

    const response = await client.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: [
        {
          inlineData: {
            mimeType: mimeType,
            data: cleanBase64,
          },
        },
        {
          text: `Instruction: Transform the person in this image into a Halloween character based on the style: "${stylePrompt}".
            
            CRITICAL GUIDELINES:
            1. EYE COLOR IS SACROSANCT: The person's original eye color MUST NOT be changed under any circumstances. If a style demands glowing eyes, you may add a subtle glow effect OVER the existing eyes, but the original color must remain visible beneath. This is the most important rule.
            2. PRESERVE CORE FACIAL IDENTITY: The person's fundamental facial structure (jawline, nose shape, chin, etc.) MUST be preserved. The person in the output image must be clearly and instantly recognizable as the person from the input image.
            3. ALLOW CREATIVE SFX & ACCESSORIES: While preserving identity, you are encouraged to add creative, non-destructive transformations. This includes:
                - Thematic accessories like hats, glasses, crowns, or horns.
                - Thematic SFX makeup such as stitches, scales, cracks, veins, or monster-like skin textures.
                - These additions should be applied like high-quality movie prosthetics and makeup, not by changing the underlying face.
            4. TRANSFORM THE CLOTHING: Completely change the person's clothes into a full, photorealistic costume that matches the style prompt. This is a complete redesign of the clothing.
            5. PRESERVE THE BACKGROUND: The original background of the photo MUST remain exactly the same. IGNORE any instructions in the style prompt about changing the background.
            6. MAINTAIN PHOTOREALISM: The final image must look like a real, high-quality photograph.

            Return ONLY the edited image. Do not add any text.`,
        },
      ],
    });

    // 2. Extract Image
    const candidate = response.candidates?.[0];

    // Check if the model refused to generate due to safety
    // The SDK might return finishReason as a string property
    if (candidate?.finishReason === 'SAFETY') {
      throw new Error("The image was blocked by safety filters. Please try a different photo or a less scary style.");
    }

    if (candidate?.content?.parts) {
      for (const part of candidate.content.parts) {
        if (part.inlineData && part.inlineData.data) {
          // Construct data URL
          return `data:image/png;base64,${part.inlineData.data}`;
        }
      }
      
      // If we are here, we might have text explaining why it failed
      const textPart = candidate.content.parts.find(p => p.text);
      if (textPart && textPart.text) {
          console.warn("AI returned text instead of image:", textPart.text);
          // Don't show the full raw text to user as it might be confusing, but use it for debugging
          // Often it says "I cannot process this image containing..."
          throw new Error("The AI could not process this specific image. Please try another photo.");
      }
    }

    throw new Error("No image generated by the AI.");

  } catch (error) {
    console.error("Gemini API Error:", error);
    throw error;
  }
};